## 正则表达式小结

可分为完整匹配和非完整匹配，完整匹配须用`^$`符号表示以`..`开头，以`..`结尾。其中`"|"`或符号的优先级是最低的。
示例:
正则: `^z|food$`可匹配 `z,zabcd,food,ewfwefood`因为它分别表示为以`z`开头的或以`food`结尾的字符串，因为`|`优先级是最低的，它会先计算出`^z`和`food$`
而正则：`^(z|food)$`完全不一样了，会先计算`z|food`子表达式得到的结果为`z或food`，所以最后得到`^z$`或`^food$`两种情况
所以它只能匹配字符串：`z`或`food`
常用方法有
- `Regex.IsMatch`:**用于判断某个字符串是否匹配某个正则**
- `Regex.Match`:**从字符串中根据某个正则提取出一个子字符串**
- `Regex.Matches`: **从字符串中根据某个正则提取出多个子字符串**
- `Regex.Replace`:**替换字符串中匹配某个正则的子字符串**
>提取子字符串时，有两种思路 ：
>>1、从参有许多其它内容的字符串中提取时，一般先根据子字符串特征写出正则表达式，如本例中“邮箱地址提取”的例子
>>2、从具体字符串中提取时，可写出与该字符串匹配的正则表达式，再用分组的方式提取子字符串 ,如本例中“提取IP地址信息”的例子

## 贪婪模式小结
  默认开启的是贪婪模式，这种模式是针对有数量限定符的正则表达式而言
如：`?`,`*`,`+`,`{3,}`，这种限定符尽可能多地匹配字符，
案例：**贪婪匹配**示例中有字符串：`"。111。111111。1111。1111。"`和正则表达式：`(.)*?。`,用这个正则进行匹配时，
会得到如下结果：
![][resImg]

### 分析
- 运行代码如下：
``` C#
    string str = "。111。111111。1111。1111。";

    MatchCollection matchCollection = Regex.Matches(str, "(.)*?。");
    foreach (Match item in matchCollection)
    {
        Console.WriteLine(item.Value);
    }
    Console.ReadKey();
```

- **匹配分析**
    例如匹配子串`111。`时，根据 正则`(.)*?。`，它会先检查第一个`1`后面有没有句号，发现没有，好！然后再匹配第二个`1`，然后再检查它的后面有没有句号，
    再次没有，然后在来到第三个`1`，再做同样的检查，哎，这个`1`的后面有个句号，所以就可以匹配上111。这样一个子串。

- **由此可以得出一个结论：在禁用限定符的贪婪匹配时，它会尽可能地找到匹配子串，然后依次把限定匹配的数量递增**
- **直到找到匹配的子串或没有找到匹配子串，而在贪婪模式下，情况正好相反。**

[resImg]:/img/res.png "结果图片"
